### C与C++
- C面向过程，是结构化的程序设计语言。
- C++面向对象，具有继承、多态和封装的特性。

### 编译过程
1. 预处理
  - 宏替换
  - 头文件展开
  - 去掉注释
  - 输出.i文件
2. 编译
  - 由编译器（gcc）完成，生成汇编文件（.s）
3. 汇编
  - 由汇编器（as）完成，生成目标文件（.o）
4. 链接
  - 由链接器（ld）完成，生成可执行文件

### 指针&引用
1. 指针存的是对象地址，本身是变量，可以更改
2. 引用是给变量起别名，一经初始化，不可更改绑定
3. 如果确认只是使用某个变量的别名，就使用引用；如果只是暂时指向某个变量，有可能还会指向其他变量甚至需要为空时，就使用指针。

### static
1. 修饰全局变量
2. 修饰局部变量，该变量只初始化一次，生命周期直到程序结束
3. 修饰普通函数，该函数仅在该文件中使用，外部文件不能访问
4. 修饰成员变量，该变量在第一次创建对象时初始化，且与其他对象共享该变量，只有一份存储，可以通过类名访问，也可以通过对象访问。
5. 修饰成员函数，该函数只能访问静态成员变量和调用静态成员函数，可以通过类名进行访问。

### const
1. 修饰普通变量，表示该变量不可更改
2. const int *p和int * const p含义不同，前者修饰指向的对象，后者修饰指针；类似的还有const int * const p
3. 修饰成员变量，该变量已经初始化，不可更改
4. 修饰函数返回值，一般返回一个常引用，表示只读
5. 修饰函数本身，表示该函数只能对成员变量进行读操作，以及只能调用常成员函数。

### volatile
1. 编译器优化有可能将某个变量a放入寄存器，这就导致存在这样一个问题：第一次从内存读取a，然后放入寄存器，后面继续访问时，就会从寄存器访问，当由于某种原因导致内存中的a被修改时，从寄存器将读取未更新的值。
2. 被修饰的变量不再被编译器进行优化，每次都从内存中获取值
3. 使用场景：
  - 多线程下，共享的标识符
  - 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义
  - 中断服务程序中修改的供其它程序检测的变量需要加volatile

### mutable
1. 由于const成员函数无法修改成员变量，但是某些场景下需要进行修改，而mutable修饰的成员变量，可以在const成员函数中被修改。
2. 使用场景：
  - 多线程下，再使用互斥锁时，使用mutable修饰互斥锁成员变量，在const成员函数中就可以获取锁，从而实现现场安全。
  - 一般，不影响对象状态的成员变量可以使用mutable进行修饰，从而在const成员函数中进行写操作。

### 容器
#### vector
##### 1. emplace
```
// vector::emplace
#include <iostream>
#include <vector>

int main ()
{
  std::vector<int> myvector = {10,20,30};

  auto it = myvector.emplace ( myvector.begin()+1, 100 );
  myvector.emplace ( it, 200 );
  myvector.emplace ( myvector.end(), 300 );

  std::cout << "myvector contains:";
  for (auto& x: myvector)
    std::cout << ' ' << x;
  std::cout << '\n';

  return 0;
}
```
在指定位置上添加一个元素，并返回该元素的迭代器。它会导致其后的迭代器失效。

##### 2. empalce_back
```
#include <iostream>
#include <vector>

int main ()
{
  std::vector<int> myvector = {10,20,30};

  myvector.emplace_back (100);
  myvector.emplace_back (200);

  std::cout << "myvector contains:";
  for (auto& x: myvector)
    std::cout << ' ' << x;
  std::cout << '\n';

  return 0;
}
```
不同于push_back，emplace_back会使用传入的元素构造对象，而不是先创建临时对象。
##### 3. 动态扩容
- 从空间角度：扩容因子越大，预留的空间越大，浪费的空间就越多。
- 从时间角度：扩容因子越小，扩容的次数就越多，时间开销就越大。
- 假设扩容因子为2，每次扩容情况为：1,2,4,8,16,32……。当我们释放了4的空间，然后寻找8的新空间，再次扩容，释放8，寻找16的空间。显然1+2+4+8=15<16，也就是上次释放的空间永远也不能被下一次扩容利用，这对内存非常不友好，比如造成内存碎片等问题。而当k=1.5时则可以避免这种情况。理论上最佳扩容因子为黄金分割率，即1.618.
#### list
- 双向链表
- 插入、删除快，随机访问性能差
- 适用于频繁插入和删除，但随机访问少
- 删除某个迭代器后其他迭代器不受影响

#### Queue，deque&priority_queue
- queue是队列，通过循环数组实现，注意获取队首元素是通过front函数。显示队尾使用back函数。
- deque是双向队列。是可以在两端扩展和收缩的连续容器。Deque容器使用分段数组来存放数据，将每一段的连续空间的首地址存放在索引表中，当头部或者尾部的数组空间满时，就会重新分配一个数组，然后在索引表的头部或尾部添加新的数组首地址。deque的操作有push_front和push_back。back和front分别用来获取队尾和队首元素。
![deque存储模型](deque.PNG "deque存储模型")
- priority_queue是基于堆实现。定义priority_queue<type, container, func>。分别传入关键字类型，存放数据的容器和比较函数。当使用基本数据类型时，只需要传入数据类型即可，默认为大根堆。获取队首元素使用top函数。操作有push和pop。

#### pair&tuple
- pair是将2个数据组合成一个数据。他可以作为map的元素。使用first和second可以获取这两个元素值。make_pair函数可以定义一个pair类型变量。如make_pair(1, 1)。也可直接使用pair<int, int> p(1, 1)。
- tuple可以将多个数据组合成一个数据。比如auto t = make_tuple(1, “2”, 1.1, ‘3’);以通过get来获取每个位置的值。如get<0>(t)的值就是1。还可以基于类型，但保证类型唯一，如get<char>(t)的值就是’3’。

#### map & set
##### 1. key_compare & value_comp
- key_compare：比较器类型。
```
map<int, int> my_map;
map<int, int>::key_compare my_comp = my_map.key_comp();
my_comp(1, 2); // 返回true
```
- value_comp：返回比较器对象，参数时pair对象
```
std::map<char,int> mymap;
mymap.value_comp()(*mymap.begin(), *mymap.rbegin()); // 返回ture
```

##### 2. emplace & emplace_hint
```
map<int, string> my_map;
ret1 = my_map.emplace(1, "abc"); // 直接使用abc进行string对象构造
my_map.insert({1, "cdb"}); // 先创建string(cdb)临时对象，再调用移动构造函数
ret2 = my_map.emplace_hint(my_map.end(), 1, "abc");
// emplace和emplace_hint的返回值是一个pair<map::iterator, bool>
// first为被插入元素的迭代器，second为插入是否成功（key已存在，则插入失败）
```
##### 3. lower_bound & upper_bound
- lower_bound(k)，返回第一个不在k之后的迭代器，即<=k的第一个key
- upper_bound(k)，返回第一个在k之后的迭代器，即>k的第一key

#### unordered_map & unordered_set
- 底层实现为哈希表，所以查询和插入是常数开销，但是当数据量很大时，可能会产生很多冲突，致使性能降低。需要解决冲突。

### 类
#### 权限
1. public
2. potected
  - 类外不可见
  - 对子类可见
  - 子类拥有同样权限
3. private
  - 类外不可见
  - 对子类不可见，但占用空间
#### struct & class
1. struct多用于数据结构，默认权限为public
2. class可用于模板中，声明类型变量
#### static & non-static
- static成员具有共享的属性，即只有一份存储，可通过对象访问，也可直接通过类访问
- static函数只能访问static成员
#### const
- const成员，在构造的时候初始化，之后不可更改
- const函数，只能对成员进行读操作
#### 构造函数&析构函数
- 父类的析构函数必须是虚函数
- 构造/析构函数函数不存在时，会默认生成
#### 拷贝构造、赋值运算符
- 拷贝构造，故名思意，是将其他对象的内容拷贝了一份
- 赋值运算符实现时，注意是否赋值的自身，并返回对象的引用
#### 移动拷贝构造、移动赋值运算
- 移动拷贝构造，被拷贝的对象是一个右值
- 移动赋值运算符，被赋值的对象是一个右值
#### 重载、覆盖、重写
- 重载，同名，但参数类型，个数等不同
- 覆盖，子类拥有同名函数，有自身的实现
- 重写，子类重写虚函数
#### 虚函数&多态
- 多态，函数重载和虚函数
- 子类继承父类，并重写父类的虚函数，然后通过父类指针来访问该虚函数
  - 原理：创建对象时，会生成一个虚表指针，该指针指向虚函数表，虚函数表中存放该对象的虚函数地址。
  - 因此一个拥有虚函数的类，至少存储一个8字节的虚表指针
#### this
- 对象调用成员函数时，隐式传入的一个指向该对象的指针
#### 初始化列表
- 构造函数中，常使用初始化列表来初始化一些成员，顺序和成员在代码中的顺序一致
#### 友元
- 友元函数，该函数用类的全部权限
- 友元类，该友元类拥有类的全部权限
- 破坏了类的封装
#### 单继承、多继承
- 继承父类的成员与方法，但private权限对子类不可见
- 菱形继承问题：TODO
#### 对象模型

### new、delete、delete[]
- new动态创建内存，并调用类的构造函数进行成员初始化
- delete与new配合使用，析构成员，并释放内存
- delete[]与new配合使用，调用每个对象的析构函数，最后释放内存
- 如果创建的是对象数组，但是释放时调用的不是delete[]，那么内存将会被全部释放，但对象只析构了一个

### 左值&右值
- 左值，可以取地址的，有名字的值
- 右值，不可以取地址或者没有名字，比如表达式，函数的返回值等
- 可以通过std::move()来转化左值为右值

### 完美转发
- TODO

### 智能指针
- unique_ptr，独享智能指针，所有权只能被一个对象拥有，不可以被拷贝，赋值，但可以被剥夺所有权
- shared_ptr，共享智能指针，所有权可以被多个对象共享，可以拷贝和赋值，依赖引用计数器，计数器为0时，释放内存
- weak_ptr，对shared_ptr的补充，需要依赖shared_ptr进行创建，不占用引用计数，可以解决**shared_ptr循环引用**的问题

### 闭包
- TODO

### 内存管理
- TODO
