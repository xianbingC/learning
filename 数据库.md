### MySQL
#### 范式
- 第一范式：数据库表的每一列都是不可分割的基本数据项
- 第二范式：除主键外的所有列都必须依赖于主键
- 第三范式：属性不依赖于其他非主属性

#### 数据库事务
- 一个最小的不可分割的工作单元，能够保证业务的完整性
- 事务特性：
    1. 原子性：事务是最小的单位，不可分割
    2. 一致性：事务执行前后，数据库从一个一致性状态转换到另一个一致性状态
    3. 隔离性：事务之间是隔离的
    4. 持久性：事务提交之后对数据库的改变是永久的
- 隔离级别：
    1. 读未提交：一个事务提交之前，其他事务可以看到它对数据库的修改。问题：脏读
    2. 读已提交：事务只有在提交之后，其他事务才能看到它对数据库的修改。问题：不可重复读，同样条件下，两次读到的结果不一致
    3. 可重复读：操作同一张表的事务a更新的数据也不能被事务b读到。出现幻读的问题。同样条件下两次读到的记录数不一致
    4. 串行化：读会加读锁，写会加写锁，当发生读写冲突时，后执行的事务，必须等前一个事务执行完后，才能继续执行
- Mysql的事务不是绑定在mysql服务器上的，而是与存储引擎相关：MYISAM（my-z[ei]m）不支持事务，innodb支持事务

#### 数据库表优化
- 表的垂直拆分：多个列拆分成多个表，将常用/不常用字段单独放在一张表，把大字段单独放在一张表。
- 表的水平拆分：对表的id进行hash，比如要拆分成5个表，mod(id, 5)取出0-4个值，然后将对应hashID的数据存入到不同的表中。
    1. 带来的问题，数据查询、统计及后台报表的操作。
    2. 带来的好处，降低查询时需要读取的数据和索引的页数，同时也降低了索引的层数，提高查询速度。

#### 视图
- 什么是视图？
    1. 视图是一种虚拟的表，具有物理表相同的功能。对视图的修改不影响基本表。
    2. 提高重用性，经常访问字段放到视图中。
    3. 重构数据库，假如因某种原因将user表分成了usera和userb，此时需要访问user表，则需要创建视图将两张表再合到一起。
    4. 创建视图：create view as myview as 查询语句。

#### 触发器
- 触发器示例
```sql
create trigger mytrig before update
on account for each row
begin
		if new.amount < 0 then
			set new.amount = 0;
		else if new.amount > 100 then
			set new.amount = 100;
		end if;
end
```
- Insert型trigger中new表示即将（before）或已经（after）插入的数据
- Update型trigger中new表示即将或已经更新的新数据，old即将或已经被修改的数据
- Delete型trigger中old表示即将或已经删除的数据

#### Drop、delete、truncate
- drop table mytable;删除表的数据和表
- delete table mytable (where 字句);可以删除满足条件的行，当要删除表的全部数据时，也是一行一行的删除。会触发delete触发器
- truncate table mytable;删除整张表的数据但保留表

#### 数据库锁
- MySQL支持以下3种锁:
    - 表级锁：开销小，加锁块；不会出现死锁；锁粒度大，发生冲突的概率高，并发度最低。
    - 行级锁：开销大，加锁慢；会出现死锁；锁粒度小，发生冲突概率低，并发度最高。
    - 页面锁：介于上述两者之间
- 表锁的两种模式：表共享读锁和表独占写锁
- 行锁:
    1. 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁
    2. 排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁
- 为了允许行锁和表锁共存，实现多粒度锁机制，innoDB内部使用两种意向锁（表锁）
    1. 意向共享锁（IS）：事务在给一个数据行加共享锁前必须先取得该表的IS锁
    2. 意向排他锁（IX）：事务在给一个数据行加排他锁前必须先取得该表的IX锁
- 加锁语句
    - 意向锁是InnoDB自动加的
    - 显示的加共享锁：select* from table_name where … lock in share mode
    - 显示的加排他锁：select* from table_name where … for update
- InnoDB行锁实现方式
    - 只有通过索引条件检索数据，InnoDB才会使用行级锁，否则，使用表锁
    - 因此要注意这一特性，否则导致大量使用表锁，降低并发性
- 锁的使用场景
    1. 对于InnoDB，在大部分情况下都应该使用行锁
    2. 当需要更新大部分或全部表数据时，应该使用表锁而不是行锁
    3. 事务涉及多个表时，使用表锁可能比行锁更好的避免死锁
- **乐观锁**
    - 乐观锁假定冲突不会发生，只在更新操作之后再对冲突进行检测，一般是根据版本号。并未真正加锁，效率高。一旦锁的粒度掌握不好，容易发生业务失败。
    - Version方式：当数据被修改时，version值会加1.当线程A要更新数据时，首先读取version值，在提交更新时，再读取version值，若两次值相等，就提交更新。否则重试更新操作，直到成功。例：
    ```sql
    select version as oldversion from table_name where id = myid
update table set value = newvalue, version = oldversion+1 where version = oldversion and id = myid
    ```
    - CAS操作方式：涉及到两个操作数，即数据所在的内存值，预期值，新值。当需要更新时，判断当前内存值与之前取到的值是否相等，若相等，则用新值更新，否则重试更新操作，直到成功。
- **悲观锁**：假定冲突会发生，访问数据时，先对数据加锁，操作完之后，再解锁，悲观锁依赖数据库锁如排他锁，效率低。例：select … for update
- 索引: TODO
- SQL语句：TODO

### Redis
