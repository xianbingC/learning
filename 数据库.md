### MySQL
#### 范式
- 第一范式：数据库表的每一列都是不可分割的基本数据项
- 第二范式：除主键外的所有列都必须依赖于主键
- 第三范式：属性不依赖于其他非主属性

#### 数据库事务
- 一个最小的不可分割的工作单元，能够保证业务的完整性
- 事务特性：
    1. 原子性：事务是最小的单位，不可分割
    2. 一致性：事务执行前后，数据库从一个一致性状态转换到另一个一致性状态
    3. 隔离性：事务之间是隔离的
    4. 持久性：事务提交之后对数据库的改变是永久的
- 隔离级别：
    1. 读未提交：一个事务提交之前，其他事务可以看到它对数据库的修改。问题：脏读
    2. 读已提交：事务只有在提交之后，其他事务才能看到它对数据库的修改。问题：不可重复读，同样条件下，两次读到的结果不一致
    3. 可重复读：操作同一张表的事务a更新的数据也不能被事务b读到。出现幻读的问题。同样条件下两次读到的记录数不一致
    4. 串行化：读会加读锁，写会加写锁，当发生读写冲突时，后执行的事务，必须等前一个事务执行完后，才能继续执行
- Mysql的事务不是绑定在mysql服务器上的，而是与存储引擎相关：MYISAM（my-z[ei]m）不支持事务，innodb支持事务

#### 数据库表优化
- 表的垂直拆分：多个列拆分成多个表，将常用/不常用字段单独放在一张表，把大字段单独放在一张表。
- 表的水平拆分：对表的id进行hash，比如要拆分成5个表，mod(id, 5)取出0-4个值，然后将对应hashID的数据存入到不同的表中。
    1. 带来的问题，数据查询、统计及后台报表的操作。
    2. 带来的好处，降低查询时需要读取的数据和索引的页数，同时也降低了索引的层数，提高查询速度。

#### 视图
- 什么是视图？
    1. 视图是一种虚拟的表，具有物理表相同的功能。对视图的修改不影响基本表。
    2. 提高重用性，经常访问字段放到视图中。
    3. 重构数据库，假如因某种原因将user表分成了usera和userb，此时需要访问user表，则需要创建视图将两张表再合到一起。
    4. 创建视图：create view as myview as 查询语句。

#### 触发器
- 触发器示例
```sql
create trigger mytrig before update
on account for each row
begin
		if new.amount < 0 then
			set new.amount = 0;
		else if new.amount > 100 then
			set new.amount = 100;
		end if;
end
```
- Insert型trigger中new表示即将（before）或已经（after）插入的数据
- Update型trigger中new表示即将或已经更新的新数据，old即将或已经被修改的数据
- Delete型trigger中old表示即将或已经删除的数据

#### Drop、delete、truncate
- drop table mytable;删除表的数据和表
- delete table mytable (where 字句);可以删除满足条件的行，当要删除表的全部数据时，也是一行一行的删除。会触发delete触发器
- truncate table mytable;删除整张表的数据但保留表

#### 索引
- 索引的数据结构
    1. B-树：所有结点都存储关键字和数据
        - 非叶子结点最多有M个儿子结点
        - 根结点最少2个儿子，最多M个儿子结点
        - 除根节点外的非叶子结点最少M/2个儿子结点
        - 非叶子结点的关键字个数=儿子数-1
        - 所有叶子结点位于同一层
    2. B+树
        - 与B-树的区别在于，只有叶子结点存储数据，非叶子结点只存储关键字索引。并且叶子结点还通过指针将相邻结点连接起来
        - B+树因为中间结点不保存数据，所以磁盘页能容纳更多节点元素，更矮胖
        - B+树查询必须要查找到叶子结点，b树只需要匹配到即可。因此B+树查找更加稳定
        - 对于范围查询来说，B+树只需要遍历叶子结点链表即可，B树确需要不断地重复中序遍历
    3. 索引分类
        - 普通索引和唯一索引
        - 单个索引和复合索引
        - 聚集索引（主键索引）和非聚集索引（二级索引）
    4. 什么情况下设置索引但无法使用
        - 以“%”开OR语句前后没有同时使用索引头的like语句
        - OR语句前后没有同时使用索引
        - 对于多列索引，必须满足最左匹配原则
    5. 索引优缺点
        - 优点：加快查询速度
        - 缺点：时间上，创建索引和维护索引要耗费时间，对数据进行增删改的时候，索引也需要动态维护。空间上，索引占用物理空间
    6. 有哪些索引
        - 哈希索引：适用于值查询
        - B+索引：适用于范围
    7. 索引创建
        - Create index|key on person(name [desc]) 对person表name字段创建一个普通索引，使用降序，默认升序
        - Create unique index on teacher(name) 对teacher表name字段创建一个唯一索引
        - 创建表的时候创建：如index|key(name)、unique index|key(name)、primary key(name)等，对name字段创建普通、唯一、主键索引
        - 修改表的时候创建：如alter table score add foreign key [索引名]\(stuid) references student(id)。对score表添加一个外键stuid
    8. 显示和删除索引
        - show index from teacher  #显示teacher表的索引，包括类型，字段和名称
        - drop index index_name on teacher #删除teacher表名为index_name的索引
        - drop primary key on …#删除主键索引
        - drop foreign key index_name on ...

#### 数据库锁
- MySQL支持以下3种锁:
    - 表级锁：开销小，加锁块；不会出现死锁；锁粒度大，发生冲突的概率高，并发度最低。
    - 行级锁：开销大，加锁慢；会出现死锁；锁粒度小，发生冲突概率低，并发度最高。
    - 页面锁：介于上述两者之间
- 表锁的两种模式：表共享读锁和表独占写锁
- 行锁:
    1. 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁
    2. 排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务取得相同的数据集共享读锁和排他写锁
- 为了允许行锁和表锁共存，实现多粒度锁机制，innoDB内部使用两种意向锁（表锁）
    1. 意向共享锁（IS）：事务在给一个数据行加共享锁前必须先取得该表的IS锁
    2. 意向排他锁（IX）：事务在给一个数据行加排他锁前必须先取得该表的IX锁
- 加锁语句
    - 意向锁是InnoDB自动加的
    - 显示的加共享锁：select* from table_name where … lock in share mode
    - 显示的加排他锁：select* from table_name where … for update
- InnoDB行锁实现方式
    - 只有通过索引条件检索数据，InnoDB才会使用行级锁，否则，使用表锁
    - 因此要注意这一特性，否则导致大量使用表锁，降低并发性
- 锁的使用场景
    1. 对于InnoDB，在大部分情况下都应该使用行锁
    2. 当需要更新大部分或全部表数据时，应该使用表锁而不是行锁
    3. 事务涉及多个表时，使用表锁可能比行锁更好的避免死锁
- **乐观锁**
    - 乐观锁假定冲突不会发生，只在更新操作之后再对冲突进行检测，一般是根据版本号。并未真正加锁，效率高。一旦锁的粒度掌握不好，容易发生业务失败。
    - Version方式：当数据被修改时，version值会加1.当线程A要更新数据时，首先读取version值，在提交更新时，再读取version值，若两次值相等，就提交更新。否则重试更新操作，直到成功。例：
    ```sql
    select version as oldversion from table_name where id = myid
update table set value = newvalue, version = oldversion+1 where version = oldversion and id = myid
    ```
    - CAS操作方式：涉及到两个操作数，即数据所在的内存值，预期值，新值。当需要更新时，判断当前内存值与之前取到的值是否相等，若相等，则用新值更新，否则重试更新操作，直到成功。
- **悲观锁**：假定冲突会发生，访问数据时，先对数据加锁，操作完之后，再解锁，悲观锁依赖数据库锁如排他锁，效率低。例：select … for update
#### SQL语句
1. 创建数据库表
```sql
create database test; %创建数据库
show tables from test; %显示数据库中的表
create table student(
	sid int primary key,
	sname varchar(50) not null,
	ssex enum(‘男’, ‘女’) default ‘男’,
	sage tinyint not null
)
```
2. 查询
```sql
select sid, sname from student where ssex = ‘女’ and sage between 18 and 25;
```
3. 增加
```sql
insert into student values(1, ‘xiaoming’, ‘男’, 18);
insert into student(sid, sname, sage) values(2, ‘xiaohong’, 17);
```
4. 删除
```sql
delete table from student where sname = 'xiaoming';
```
5. 修改
```sql
update student set sage = ‘28’, sname = ‘xiaohua’ where sid = 2;
```
6. 查看语句是否使用索引
```sql
explain select * from student where sid = 1;
% possible_keys表示可能用到的索引，key表示实际用到的索引
```
![sql](sql.PNG)

### Redis
