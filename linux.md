### 进程
1. 进程控制块
    - 进程id。用pid_t类型表示。
    - 进程状态。就绪、运行、阻塞和终止。
    - 进程切换时要保存和恢复的一些寄存器。
    - 描述虚拟地址空间到物理地址的映射关系。
    - 当前进程工作目录。
    - umask掩码。
    - 文件描述符。
    - 和信号相关的信息。
    - 用户id和组id。
    - 会话和进程组。
2.	进程控制原语
    - 创建进程：
		   - 执行一个可执行文件。
		   - 在程序中执行fork或vfork函数创建子进程。父进程返回子进程的pid，子进程返回0。
    - 获取进程id
    - getpid()获取当前进程的pid。
    - getppid()获取父进程pid。
3.	exec函数簇
	调用该函数后会将当前进程的代码段和数据段替换成所要加载程序的代码段和数据段。并进入加载后的程序执行，不再返回，只有失败才会返回-1。

4. 孤儿进程、僵尸进程和守护进程
    - 孤儿进程是指当一个子进程的父进程先于子进程退出，此时子进程就变成了孤儿进程，然后init进程就会接管该进程成为其父进程。
    - 用fork创建子进程，当子进程退出时，父进程没有调用wait或waitpid函数来获取子进程的状态信息。那么子进程的进程描述符仍然保存在系统中，成为僵尸进程，进程号将一直被占用。
    - 守护进程就是一直在后台运行的进程。创建守护进程如下。
    - fork创建子进程，父进程exit()退出。使得进程脱离控制终端。之后所有的工作都在子进程中完成。
    - 在子进程调用setsid()创建新会话。子进程成为新会话的首进程。使得当前进程脱离原会话、原进程组、原控制终端的控制。
    - 在子进程中调用chdir()让根目录成为子进程的工作目录，防止占用可卸载的文件系统，如/mnt/usb。
    - 在子进程中调用umask重设文件权限掩码为0。文件权限掩码是指屏蔽掉文件权限中的对应位。由于子进程会继承父进程的文件权限掩码，所以需要重设为0，即清除掩码，这样可以增强守护进程的灵活性。
    - 在子进程关闭不需要的文件描述符。文件描述符0,、1和2也失去了存在价值，一般重定向到/dev/null。
    - 执行守护进程核心工作。
    - 守护进程中需要编码来实现kill发出的signal信号处理，达到进程的正常退出。
    - linux提供daemon(int nochdir, int noclose)函数用于创建守护进程，实现原理同上。nochdir为0时，改变进程目录为根目录。noclose为0时，将0,1,2重定向到/dev/null中。一般使用如下：
```
Int main() {
    daemon(0, 0);
	   /*在此添加需要在后台运行的程序*/
}
```
6. 进程间通信
- 管道：pipe(int *fds)函数创建一个管道，其中fds[0]为读端，fds[1]为写端。一般为了实现全双工，会创建两个管道，父进程有一个读端和一个写端，子进程有一个写端和一个读端。
- socket通信，全双工通信，详见网络编程
- 消息队列，消息队列是消息的链表，存放在内核中并由消息队列标识符标识。它提供了一个从一个进程向另一个进程发发送数据块的方法，每个数据块都可以被认为是一个类型。
    - 生命周期随内核，消息队列会一直存在；消息队列可以双向通信；克服了管道只能承载无格式字节流的缺点。
    - int msgget(key_t key, int msgflag)函数创建和访问一个消息队列。其中key是某个消息队列的名字，用ftok()产生。msgflag有IPC_CREAT和IPC_EXCL两个选项，单独使用第一个选项，那么如果消息队列不存在就会创建一个，否则打开消息队列并返回；单独使用第二个选项没有意义；两个同时使用，如果消息队列不存在则创建之，如果存在则出错返回。
    - key_t ftok(const char*pathname, int proj_id)函数调用成功返回一个消息队列的标识码，失败返回-1。
    - int msgctl(int msqid, int cmd, struct msqid_ds* buf)消息队列控制函数，cmd有三个选项，IPC_STAT，设置buf中数据为消息队列当前的关联值；IPC_SET；IPC_RMID删除消息队列。成功返回0，失败返回-1。
    - msgsnd(msqid, msg, size, msgflag\/\*默认0*\/)/msgrcv(msqid, msg, size, msgflag)向消息队列添加消息，成功返回0/从消息队列接收消息，成功返回接收的字节数。
- 共享内存：mmap映射
    1. 在非血缘进程间通信，只需要打开或创建一个文件，然后通过mmap将其映射到内存。就可以通过对映射的内存进行操作，实现内存共享。
    2. 父子进程之间可以通过匿名映射来实现，因为映射的内存是由父子进程共享的。
- 信号
	1. 每个进程收到的信号都是由内核负责发送和处理的。Linux下有64个信号。
	2. 信号产生的方法：按键产生、系统调用、软件条件产生、硬件异常、命令产生。
	3. signal(信号名，处理动作)。其中处理动作函数参数为int，返回为void。注册信号捕捉函数。
	4. sigaction()，可以设置信号屏蔽，比如自动屏蔽本信号。
	5. 内核实现信号捕捉的过程：如果信号处理动作是自定义的处理函数，那么进入用户模式执行处理函数，信号处理函数返回时，执行系统调用sigreturn再次进入内核。然后返回用户模式继续执行下一条指令。
	6. 时序竞态：设备或系统出现不恰当的执行时序，而得不到正确的结果，导致该到达响应的信号没有被响应。解决方法：可重入函数内不能含有全局变量及static变量，不能使用malloc、free。信号捕捉函数设置成可重入的。举例：比如我定时1秒钟然后调用pause挂起等待sigalrm信号唤醒。但是在此期间当前进程失去CPU，内核调度优先级高的进程取代当前进程。1秒后，闹钟超时，内核向当前进程发生SIGALRM信号，由于当前进程仍处于就绪态，信号无法处理即未决。待高优先级的进程执行结束，当前进程进入运行态，SIGALRM信号递达，执行处理函数。信号处理函数执行结束，返回当前进程主控流程，pause被调用挂起等待。欲等待alarm函数发送SIGALRM信号将自己唤醒。但是SIGALRM信号以及处理结束，程序会被永久挂起。

### 线程
1. 线程共享资源
    - 文件描述符表。
    - 每种信号的处理方式。
    - 当前工作目录。
    - 用户ID和组ID
    - 代码段、数据段、bss段个堆区
2. 线程非共享资源
    - 线程id
    - 栈空间
    - 寄存器
    - 指令计数器
    - 信号屏蔽字
    - 调度优先级
    - errno变量
3. 线程优缺点
    - 优点：提高程序并发性，开销小，线程通信、共享数据方便。
    - 缺点：库函数不稳定。调试、编写困难。对信号支持不好。线程间会相互干扰。如一个线程挂掉，会导致整个进程的线程全部挂掉。
4. 线程控制原语
    - pthread_create函数
	     - 创建一个新线程，传入参数为线程id，线程属性和线程处理函数以及处理函数的参数。
       ```
	     Pthread_create(pthread_t *thread, const pthread_attr_t* attr, void*(*func)(void*), void* arg)
       // 上述函数成功返回0，失败返回错误号。可用strerror来打印。
       // 创建线程的时候参数最好使用值传递。
       // pthread_self()返回线程id。
       // pthread_exit()或return用来退出线程。若用exit则会退出整个进程。
       ```
    - Pthread_join()函数。
      - 阻塞等待线程退出。成功返回0，失败返回错误号。
    - pthread_detach()函数
	    - 设置线程分离。
    - 线程属性设置
	    - Pthread_attr_t结构体主要成员：1.线程分离状态；2.线程栈大小；3.线程栈警戒缓冲区大小。通过pthread_attr_setdetachstate和pthread_attr_setstacksize等函数实现属性设置，不能直接设置。
### 并行与并发

### 用户线程与内核线程

### 内存模型
